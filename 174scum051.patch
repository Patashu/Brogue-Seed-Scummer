diff -Bwur "Brogue Source (Original)/BrogueCode/IO.c" "Brogue Source/BrogueCode/IO.c"
--- "Brogue Source (Original)/BrogueCode/IO.c"	2014-07-30 08:32:31.466410100 +1000
+++ "Brogue Source/BrogueCode/IO.c"	2014-07-30 11:01:54.406722200 +1000
@@ -2681,6 +2681,120 @@
 	return true;
 }
 
+boolean getInputTextStringWithCheckbox(
+                            char *inputText,
+                            boolean *checkboxResult,
+                            const char *prompt,
+                            const char *checkboxPrompt,
+                            short maxLength,
+                            const char *defaultEntry,
+                            const char *promptSuffix,
+                            short textEntryType,
+                            boolean useDialogBox) {
+	short charNum, i, x, y;
+	char keystroke, suffix[100];
+	const short textEntryBounds[TEXT_INPUT_TYPES][2] = {{' ', '~'}, {'0', '9'}};
+	cellDisplayBuffer dbuf[COLS][ROWS], rbuf[COLS][ROWS];
+	rogueEvent theEvent;
+	*checkboxResult = false;
+
+	// x and y mark the origin for text entry.
+	if (useDialogBox) {
+		x = (COLS - max(maxLength, strLenWithoutEscapes(prompt))) / 2;
+		y = ROWS / 2 - 1;
+		clearDisplayBuffer(dbuf);
+		rectangularShading(x - 1, y - 2, max(max(maxLength, strLenWithoutEscapes(prompt)), strLenWithoutEscapes(checkboxPrompt) + 2 ) + 2,
+						   6, &interfaceBoxColor, INTERFACE_OPACITY, dbuf);
+		overlayDisplayBuffer(dbuf, rbuf);
+		printString(prompt, x, y - 1, &white, &interfaceBoxColor, NULL);
+		printString(checkboxPrompt, x + 2, y + 2, &white, &interfaceBoxColor, NULL);
+		for (i=0; i<maxLength; i++) {
+			plotCharWithColor(' ', x + i, y, &black, &black);
+		}
+		plotCharWithColor(' ', x, y + 2, &black, &black); //checkbox box
+		printString(defaultEntry, x, y, &white, &black, 0);
+	} else {
+		confirmMessages();
+		x = mapToWindowX(strLenWithoutEscapes(prompt));
+		y = MESSAGE_LINES - 1;
+		message(prompt, false);
+		printString(defaultEntry, x, y, &white, &black, 0);
+	}
+
+	maxLength = min(maxLength, COLS - x);
+
+
+	strcpy(inputText, defaultEntry);
+	charNum = strLenWithoutEscapes(inputText);
+	for (i = charNum; i < maxLength; i++) {
+		inputText[i] = ' ';
+	}
+
+	if (promptSuffix[0] == '\0') { // empty suffix
+		strcpy(suffix, " "); // so that deleting doesn't leave a white trail
+	} else {
+		strcpy(suffix, promptSuffix);
+	}
+
+	do {
+		printString(suffix, charNum + x, y, &gray, &black, 0);
+		plotCharWithColor((suffix[0] ? suffix[0] : ' '), x + charNum, y, &black, &white);
+		nextBrogueEvent(&theEvent, true, false, false);
+		if (theEvent.eventType == KEYSTROKE)
+		{
+		    keystroke = theEvent.param1;
+		}
+		else
+		{
+            keystroke = (char)0;
+            if (theEvent.eventType == MOUSE_DOWN)
+            {
+                if (theEvent.param1 == x && theEvent.param2 == y + 2) //clicked on checkbox
+                {
+                    if (*checkboxResult)
+                    {
+                        *checkboxResult = false;
+                        plotCharWithColor(' ', x, y + 2, &black, &black);
+                    }
+                    else
+                    {
+                        *checkboxResult = true;
+                        plotCharWithColor('X', x, y + 2, &white, &black);
+                    }
+                }
+            }
+		}
+		if (keystroke == DELETE_KEY && charNum > 0) {
+			printString(suffix, charNum + x - 1, y, &gray, &black, 0);
+			plotCharWithColor(' ', x + charNum + strlen(suffix) - 1, y, &black, &black);
+			charNum--;
+			inputText[charNum] = ' ';
+		} else if (keystroke >= textEntryBounds[textEntryType][0]
+				   && keystroke <= textEntryBounds[textEntryType][1]) { // allow only permitted input
+
+			inputText[charNum] = keystroke;
+			plotCharWithColor(keystroke, x + charNum, y, &white, &black);
+			printString(suffix, charNum + x + 1, y, &gray, &black, 0);
+			if (charNum < maxLength) {
+				charNum++;
+			}
+		}
+	} while (keystroke != RETURN_KEY && keystroke != ESCAPE_KEY && keystroke != ENTER_KEY);
+
+	if (useDialogBox) {
+		overlayDisplayBuffer(rbuf, NULL);
+	}
+
+	inputText[charNum] = '\0';
+
+	if (keystroke == ESCAPE_KEY) {
+		return false;
+	}
+	strcat(displayedMessage[0], inputText);
+	strcat(displayedMessage[0], suffix);
+	return true;
+}
+
 void displayCenteredAlert(char *message) {
 	printString(message, (COLS - strLenWithoutEscapes(message)) / 2, ROWS / 2, &teal, &black, 0);
 }
diff -Bwur "Brogue Source (Original)/BrogueCode/MainMenu.c" "Brogue Source/BrogueCode/MainMenu.c"
--- "Brogue Source (Original)/BrogueCode/MainMenu.c"	2014-07-30 08:32:34.227624100 +1000
+++ "Brogue Source/BrogueCode/MainMenu.c"	2014-07-30 11:18:31.206940600 +1000
@@ -270,12 +270,12 @@
 	
 	short i, b, x, y, button;
 	buttonState state;
-	brogueButton buttons[6];
+	brogueButton buttons[7];
 	char whiteColorEscape[10] = "";
 	char goldColorEscape[10] = "";
 	char newGameText[100] = "", customNewGameText[100] = "";
 	rogueEvent theEvent;
-	enum NGCommands buttonCommands[6] = {NG_NEW_GAME, NG_OPEN_GAME, NG_VIEW_RECORDING, NG_HIGH_SCORES, NG_QUIT};
+	enum NGCommands buttonCommands[7] = {NG_NEW_GAME, NG_SCUM, NG_OPEN_GAME, NG_VIEW_RECORDING, NG_HIGH_SCORES, NG_QUIT};
 	
 	cellDisplayBuffer shadowBuf[COLS][ROWS];
 	
@@ -302,6 +302,12 @@
 	b++;
 	
 	initializeButton(&(buttons[b]));
+	sprintf(buttons[b].text, "     %sS%startscum      ", goldColorEscape, whiteColorEscape);
+	buttons[b].hotkey[0] = 's';
+	buttons[b].hotkey[1] = 'S';
+	b++;
+
+	initializeButton(&(buttons[b]));
 	sprintf(buttons[b].text, "     %sO%spen Game      ", goldColorEscape, whiteColorEscape);
 	buttons[b].hotkey[0] = 'o';
 	buttons[b].hotkey[1] = 'O';
@@ -598,7 +604,7 @@
     }
 }
 
-void scum(unsigned long startingSeed, short numberOfSeedsToScan, short scanThroughDepth) {
+/*void scum(unsigned long startingSeed, short numberOfSeedsToScan, short scanThroughDepth) {
     unsigned long theSeed;
     char path[BROGUE_FILENAME_MAX];
     item *theItem;
@@ -653,7 +659,7 @@
         remove(currentFilePath); // Don't add a spurious LastGame file to the brogue folder.
     }
     fclose(logFile);
-}
+}*/
 
 // This is the basic program loop.
 // When the program launches, or when a game ends, you end up here.
@@ -752,12 +758,43 @@
 				}
 				
 				rogue.nextGame = NG_NOTHING;
-				initializeRogue(rogue.nextGameSeed);
-				startLevel(rogue.depthLevel, 1); // descending into level 1
+				initializeRogue(rogue.nextGameSeed, false);
+				startLevel(rogue.depthLevel, 1, false); // descending into level 1
 				
 				mainInputLoop();
 				freeEverything();
 				break;
+            case NG_SCUM:
+                rogue.nextGamePath[0] = '\0';
+				randomNumbersGenerated = 0;
+				boolean checkboxResult = false;
+                if (getInputTextStringWithCheckbox(buf, &checkboxResult, "Find dungeon containing uncursed item(s) (, separates items):", "Stop at depth 2",
+											   64,
+											   "",
+											   "",
+											   TEXT_INPUT_NORMAL,
+											   true)
+							&& buf[0] != '\0') {
+                    rogue.nextGame = NG_NOTHING;
+                    rogue.nextGameSeed = startScum(buf, true, checkboxResult);
+                    if (rogue.nextGameSeed == 0) break;
+                    rogue.nextGamePath[0] = '\0';
+                    randomNumbersGenerated = 0;
+                    strcpy(currentFilePath, LAST_GAME_PATH);
+                    rogue.playbackMode = false;
+                    rogue.playbackFastForward = false;
+                    rogue.playbackBetweenTurns = false;
+                    initializeRogue(rogue.nextGameSeed, false);
+                    startLevel(rogue.depthLevel, 1, false); // descending into level 1
+                    mainInputLoop();
+                    freeEverything();
+                }
+                else
+                {
+                    rogue.nextGame = NG_NOTHING;
+                    break; // Don't start a new game after all.
+                }
+                break;
 			case NG_OPEN_GAME:
 				rogue.nextGame = NG_NOTHING;
 				path[0] = '\0';
@@ -795,9 +832,9 @@
 				if (openFile(path)) {
 					randomNumbersGenerated = 0;
 					rogue.playbackMode = true;
-					initializeRogue(0); // Seed argument is ignored because we're in playback.
+					initializeRogue(0, false); // Seed argument is ignored because we're in playback.
 					if (!rogue.gameHasEnded) {
-						startLevel(rogue.depthLevel, 1);
+						startLevel(rogue.depthLevel, 1, false);
                         rogue.playbackPaused = true;
 						displayAnnotation(); // in case there's an annotation for turn 0
 					}
@@ -828,10 +865,6 @@
 				rogue.nextGame = NG_NOTHING;
 				printHighScores(false);
 				break;
-            case NG_SCUM:
-                rogue.nextGame = NG_NOTHING;
-                scum(1, 1000, 5);
-                break;
 			case NG_QUIT:
 				// No need to do anything.
 				break;
diff -Bwur "Brogue Source (Original)/BrogueCode/Monsters.c" "Brogue Source/BrogueCode/Monsters.c"
--- "Brogue Source (Original)/BrogueCode/Monsters.c"	2014-07-30 08:32:34.989683300 +1000
+++ "Brogue Source/BrogueCode/Monsters.c"	2014-07-30 11:01:54.441729300 +1000
@@ -335,6 +335,39 @@
     return false;
 }
 
+void monsterNameWithMutation(char *buf, creature *monst, boolean includeArticle) {
+
+	if (monst == &player) {
+		strcpy(buf, "you");
+		return;
+	}
+	if (canSeeMonster(monst) || rogue.playbackOmniscience) {
+		if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
+
+			assureCosmeticRNG;
+			sprintf(buf, "%s%s", (includeArticle ? "the " : ""),
+					monsterCatalog[rand_range(1, NUMBER_MONSTER_KINDS - 1)].monsterName);
+			restoreRNG;
+
+			return;
+		}
+		if (monst->mutationIndex >= 0)
+		{
+		    sprintf(buf, "%s%s %s", (includeArticle ? (monst->creatureState == MONSTER_ALLY ? "your " : "the ") : ""),
+				mutationCatalog[monst->mutationIndex].title, monst->info.monsterName);
+		}
+		else
+		{
+		    sprintf(buf, "%s%s", (includeArticle ? (monst->creatureState == MONSTER_ALLY ? "your " : "the ") : ""),
+				monst->info.monsterName);
+		}
+		return;
+	} else {
+		strcpy(buf, "something");
+		return;
+	}
+}
+
 boolean monstersAreTeammates(const creature *monst1, const creature *monst2) {
 	// if one follows the other, or the other follows the one, or they both follow the same
 	return ((((monst1->bookkeepingFlags & MB_FOLLOWER) && monst1->leader == monst2)
diff -Bwur "Brogue Source (Original)/BrogueCode/Movement.c" "Brogue Source/BrogueCode/Movement.c"
--- "Brogue Source (Original)/BrogueCode/Movement.c"	2014-07-30 08:32:35.733740800 +1000
+++ "Brogue Source/BrogueCode/Movement.c"	2014-07-30 11:01:54.454730600 +1000
@@ -2059,7 +2059,7 @@
             rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
             rogue.depthLevel++;
             message("You descend.", false);
-            startLevel(rogue.depthLevel - 1, stairDirection);
+            startLevel(rogue.depthLevel - 1, stairDirection, false);
             if (rogue.depthLevel > rogue.deepestLevel) {
                 rogue.deepestLevel = rogue.depthLevel;
             }
@@ -2082,7 +2082,7 @@
 			} else {
                 //copyDisplayBuffer(fromBuf, displayBuffer);
 				message("You ascend.", false);
-				startLevel(rogue.depthLevel + 1, stairDirection);
+				startLevel(rogue.depthLevel + 1, stairDirection, false);
                 //copyDisplayBuffer(toBuf, displayBuffer);
                 //irisFadeBetweenBuffers(fromBuf, toBuf, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), 10, true);
 			}
diff -Bwur "Brogue Source (Original)/BrogueCode/Recordings.c" "Brogue Source/BrogueCode/Recordings.c"
--- "Brogue Source (Original)/BrogueCode/Recordings.c"	2014-07-30 08:32:37.067844300 +1000
+++ "Brogue Source/BrogueCode/Recordings.c"	2014-07-30 11:01:54.467726600 +1000
@@ -640,8 +640,8 @@
         freeEverything();
         randomNumbersGenerated = 0;
         rogue.playbackMode = true;
-        initializeRogue(0); // Seed argument is ignored because we're in playback.
-        startLevel(rogue.depthLevel, 1);
+					initializeRogue(0, false); // Seed argument is ignored because we're in playback.
+					startLevel(rogue.depthLevel, 1, false);
         if (useProgressBar) {
             blackOutScreen();
         }
@@ -1128,10 +1128,10 @@
 	randomNumbersGenerated = 0;
 	rogue.playbackMode = true;
 	rogue.playbackFastForward = true;
-	initializeRogue(0); // Calls initRecording(). Seed argument is ignored because we're initially in playback mode.
+	initializeRogue(0, false); // Calls initRecording(). Seed argument is ignored because we're initially in playback mode.
 	if (!rogue.gameHasEnded) {
 		blackOutScreen();
-		startLevel(rogue.depthLevel, 1);
+		startLevel(rogue.depthLevel, 1, false);
 	}
 	
 	if (rogue.howManyTurns > 0) {
diff -Bwur "Brogue Source (Original)/BrogueCode/Rogue.h" "Brogue Source/BrogueCode/Rogue.h"
--- "Brogue Source (Original)/BrogueCode/Rogue.h"	2014-07-30 08:32:37.783898100 +1000
+++ "Brogue Source/BrogueCode/Rogue.h"	2014-07-30 11:01:54.482726900 +1000
@@ -2177,9 +2177,9 @@
 	NG_NEW_GAME,
 	NG_NEW_GAME_WITH_SEED,
 	NG_OPEN_GAME,
+	NG_SCUM,
 	NG_VIEW_RECORDING,
 	NG_HIGH_SCORES,
-    NG_SCUM,
 	NG_QUIT,
 };
 
@@ -2599,7 +2599,7 @@
 	boolean fileExists(const char *pathname);
 	boolean chooseFile(char *path, char *prompt, char *defaultName, char *suffix);
 	boolean openFile(const char *path);
-	void initializeRogue(unsigned long seed);
+	void initializeRogue(unsigned long seed, boolean scumming);
 	void gameOver(char *killedBy, boolean useCustomPhrasing);
     void victory(boolean superVictory);
 	void enableEasyMode();
@@ -2747,7 +2747,7 @@
 	void executeMouseClick(rogueEvent *theEvent);
 	void executeKeystroke(signed long keystroke, boolean controlKey, boolean shiftKey);
 	void initializeLevel();
-	void startLevel (short oldLevelNumber, short stairDirection);
+	void startLevel (short oldLevelNumber, short stairDirection, boolean scumming);
 	void updateMinersLightRadius();
 	void freeCreature(creature *monst);
 	void emptyGraveyard();
diff -Bwur "Brogue Source (Original)/BrogueCode/RogueMain.c" "Brogue Source/BrogueCode/RogueMain.c"
--- "Brogue Source (Original)/BrogueCode/RogueMain.c"	2014-07-30 08:32:38.476956400 +1000
+++ "Brogue Source/BrogueCode/RogueMain.c"	2014-07-30 11:19:51.179133500 +1000
@@ -207,7 +207,7 @@
 // Seed is used as the dungeon seed unless it's zero, in which case generate a new one.
 // Either way, previousGameSeed is set to the seed we use.
 // None of this seed stuff is applicable if we're playing a recording.
-void initializeRogue(unsigned long seed) {
+void initializeRogue(unsigned long seed, boolean scumming) {
 	short i, j, k;
 	item *theItem;
 	boolean playingback, playbackFF, playbackPaused;
@@ -239,7 +239,7 @@
 	}
     
     //benchmark();
-    
+    if (!scumming)
 	initRecording();
 	
     levels = malloc(sizeof(levelData) * (DEEPEST_LEVEL+1));
@@ -295,7 +295,7 @@
 		}
 	}
 	restoreRNG;
-	
+    if (!scumming)
 	zeroOutGrid(displayDetail);
 	
 	for (i=0; i<NUMBER_MONSTER_KINDS; i++) {
@@ -574,9 +574,11 @@
 //			theItem = addItemToPack(theItem);
 //		}
 	}
+	if (!scumming) {
 	blackOutScreen();
 	welcome();
 }
+}
 
 // call this once per level to set all the dynamic colors as a function of depth
 void updateColors() {
@@ -588,7 +590,7 @@
 	}
 }
 
-void startLevel(short oldLevelNumber, short stairDirection) {
+void startLevel(short oldLevelNumber, short stairDirection, boolean scumming) {
 	unsigned long oldSeed;
 	item *theItem;
 	short loc[2], i, j, x, y, px, py, flying, dir;
@@ -713,9 +715,9 @@
 	
 	//	Prepare the new level
 	
-	rogue.minersLightRadius = 2.25 + (DCOLS - 1) * (float) pow(0.85, rogue.depthLevel);
+	if (!scumming)  { rogue.minersLightRadius = 2.25 + (DCOLS - 1) * (float) pow(0.85, rogue.depthLevel);
 	updateColors();
-	updateRingBonuses(); // also updates miner's light
+	updateRingBonuses(); } // also updates miner's light
 	
 	if (!levels[rogue.depthLevel - 1].visited) { // level has not already been visited
         levels[rogue.depthLevel - 1].scentMap = allocGrid();
@@ -770,7 +772,8 @@
 		//logLevel();
 		
 		// Simulate 50 turns so the level is broken in (swamp gas accumulating, brimstone percolating, etc.).
-		timeAway = 50;
+		if (!scumming) { timeAway = 50; }
+		else { timeAway = 0; }
 		
 	} else { // level has already been visited
 		
@@ -900,7 +903,7 @@
 		&& !cellHasTerrainFlag(player.xLoc, player.yLoc, (T_ENTANGLES | T_OBSTRUCTS_PASSABILITY))) {
 		rogue.inWater = true;
 	}
-	
+    if (!scumming) {
 	updateMapToShore();
 	updateVision(true);
     rogue.aggroRange = currentAggroValue();
@@ -909,8 +912,10 @@
 	for (monst = monsters->nextCreature; monst != NULL; monst = monst->nextCreature) {
 		updateMonsterState(monst);
 	}
+    }
 	
 	rogue.playbackBetweenTurns = true;
+	if (!scumming) {
 	displayLevel();
 	refreshSideBar(-1, -1, false);
 	
@@ -922,6 +927,509 @@
     deleteAllFlares(); // So discovering something on the same turn that you fall down a level doesn't flash stuff on the previous level.
     hideCursor();
 }
+}
+
+//scumming functions
+
+/*
+int getExcited(item *theItem, int *excitement)
+{
+	int excitementdelta = 0;
+	if (theItem->category == WEAPON)
+	{
+		if (theItem->enchant2 == W_QUIETUS)
+			excitementdelta = 10;
+		else if (theItem->enchant2 == W_PARALYSIS)
+			excitementdelta = 10;
+		else if (theItem->enchant2 == W_SLOWING)
+			excitementdelta = 10;
+		else if (theItem->enchant2 == W_CONFUSION)
+			excitementdelta = 10;
+		else if (theItem->kind == BROADSWORD
+				|| theItem->kind == HAMMER
+				|| theItem->kind == PIKE
+				|| theItem->kind == WAR_AXE)
+			excitementdelta = theItem->enchant1 + 1;
+	}
+	else if (theItem->category == ARMOR)
+	{
+		if (theItem->kind >= BANDED_MAIL)
+		{
+			if (theItem->enchant2 == A_ABSORPTION
+				|| theItem->enchant2 == A_REPRISAL
+				|| theItem->enchant2 == A_REFLECTION)
+				excitementdelta = 5;
+			else if (theItem->kind == SPLINT_MAIL)
+				excitementdelta = theItem->enchant1;
+			else if (theItem->kind == PLATE_MAIL)
+				excitementdelta = theItem->enchant1 + 3;
+		}
+	}
+	else if (theItem->category == POTION)
+	{
+		if (theItem->kind == POTION_GAIN_STRENGTH)
+			excitementdelta = 1;
+		else if (theItem->kind == POTION_GAIN_LEVEL)
+			excitementdelta = 1;
+	}
+	else if (theItem->category == SCROLL)
+	{
+		if (theItem->kind == SCROLL_ENCHANT_ITEM)
+			excitementdelta = 1;
+	}
+	else if (theItem->category == STAFF)
+	{
+		excitementdelta = (theItem->enchant1 + 1) / 2;
+	}
+	else if (theItem->category == WAND && theItem->kind != WAND_INVISIBILITY)
+	{
+		excitementdelta = 1;
+	}
+	else if (theItem->category == RING)
+	{
+		excitementdelta = theItem->enchant1 - 1;
+	}
+	if (excitementdelta > 0) {
+		*excitement += excitementdelta;
+		return excitementdelta;
+	}
+	return 0;
+}
+*/
+
+boolean isEnchant(item *theItem)
+{
+    return (theItem->category == SCROLL && theItem->kind == SCROLL_ENCHANTING);
+}
+
+boolean isStrength(item *theItem)
+{
+    return (theItem->category == POTION && theItem->kind == POTION_STRENGTH);
+}
+
+boolean isLife(item *theItem)
+{
+    return (theItem->category == POTION && theItem->kind == POTION_LIFE);
+}
+
+boolean isBuff(item *theItem)
+{
+    return (
+               (theItem->category == SCROLL && theItem->kind == SCROLL_ENCHANTING)
+            || (theItem->category == POTION && (theItem->kind == POTION_STRENGTH || theItem->kind == POTION_LIFE ))
+            );
+}
+
+boolean isSeparator(char c)
+{
+    return (c == ',' || c == ';' || c == '&' || c == '|' || c == '.');
+}
+
+unsigned long seedPeer(unsigned long int seed)
+{
+    initializeRogue(seed, true);
+    rogue.playbackOmniscience = true;
+    char textbuf[255];
+    char itembuf[255];
+    char monstbuf[255];
+    int enchantcount = 0;
+    int strengthcount = 0;
+    int lifecount = 0;
+    item *theItem;
+    //for each floor...
+    while (rogue.depthLevel <= AMULET_LEVEL)
+    {
+        printf("\nDepth %d:\n", rogue.depthLevel);
+        startLevel(max(rogue.depthLevel - 1, 1), 1, true);
+
+        //items
+        for (theItem = floorItems->nextItem; theItem != NULL; theItem = theItem->nextItem) {
+            itemName(theItem, itembuf, true, false, NULL);
+            if (strstr(itembuf, "gold pieces") == NULL) {
+                if (pmap[theItem->xLoc][theItem->yLoc].machineNumber > 0)
+                {
+                    sprintf(textbuf, " (in machine %d)", pmap[theItem->xLoc][theItem->yLoc].machineNumber);
+                    strcat(itembuf, textbuf);
+                }
+                printf("%s\n", itembuf);
+            }
+            if (isEnchant(theItem)) ++enchantcount;
+            if (isStrength(theItem)) ++strengthcount;
+            if (isLife(theItem)) ++lifecount;
+        }
+
+        //check for captive allies
+        creature *monst;
+        for (monst = monsters; monst != NULL; monst = monst->nextCreature)
+        {
+            //check for items in monsters' pockets too
+            if (monst->carriedItem != NULL)
+            {
+                theItem = monst->carriedItem;
+                itemName(theItem, itembuf, true, false, NULL);
+                if (strstr(itembuf, "gold pieces") == NULL) {
+                    monsterNameWithMutation(monstbuf, monst, false);
+                    printf("%s (carried by %s)\n", itembuf, monstbuf);
+                }
+                if (isEnchant(theItem)) ++enchantcount;
+                if (isStrength(theItem)) ++strengthcount;
+                if (isLife(theItem)) ++lifecount;
+            }
+            if (monst->bookkeepingFlags & MB_CAPTIVE)
+            {
+                monsterNameWithMutation(monstbuf, monst, false);
+                printf("captive %s\n", monstbuf);
+            }
+        }
+        rogue.depthLevel++;
+    }
+    printf("\nIn the monster carried item queue: \n");
+    for (theItem = monsterItemsHopper->nextItem; theItem != NULL; theItem = theItem->nextItem) {
+        itemName(theItem, itembuf, true, false, NULL);
+        if (strstr(itembuf, "gold pieces") == NULL) {
+            printf("%s (carried by ???)\n", itembuf);
+        }
+    }
+
+    rogue.playbackOmniscience = false; emptyGraveyard(); freeEverything();
+    printf("\nThat seed had %d enchanting scrolls.\n", enchantcount);
+    printf("That seed had %d potions of strength.\n", strengthcount);
+    printf("That seed had %d potions of life.\n", lifecount);
+    fflush(stdout);
+    return 0;
+}
+
+unsigned long startScum(char* target, boolean gui, boolean inahurry)
+{
+    char target2[255]; int i = 0; int j = 0; const int MAX_TARGETS = 16;
+    //step 0: lower case
+    for (i = 0; target[i]; ++i) { target[i] = tolower(target[i]); }
+    strcpy(target2, target);
+
+    //we're going to split char* target into up to MAX_TARGETS targets
+    char *targets[MAX_TARGETS];
+    boolean matches[MAX_TARGETS]; for (i = 0; i < MAX_TARGETS; ++i) { matches[i] = false;}
+    targets[0] = target2;
+    short numtargets = 0;
+
+    char *end = target2;
+    //get pointer to end of target2
+    while (*end != '\0') { ++end; }
+
+    //step 1: find all separators, place positions in an array
+    for (i = 0; target2[i]; ++i) {
+        if (isSeparator(target2[i]))
+        {
+            targets[numtargets] = &target2[i];
+            //step 2: floodfill around separators into whitespace/separators with nulls
+            //starting at separator go forwards
+            char *p = targets[numtargets];
+            while (*p == ' ' || isSeparator(*p)) { *p = '\1'; ++p; }
+            if (p >= end) continue; //make sure we stayed in bounds
+            //starting BEFORE separator go backwards
+            p = targets[numtargets]; --p;
+            while (*p == ' ' || isSeparator(*p)) { *p = '\1'; --p; }
+            //NOW we move onto the next one
+            ++numtargets;
+        }
+        if (numtargets == 0) { numtargets = 1; }
+    }
+
+    //turn \1 into \0
+    for (i = 0; target2[i]; ++i) { if (target2[i] == '\1') target2[i] = '\0'; }
+
+    //step 3: move pointers to separators forward until they point to non-null (= our targets)
+    for (i = 0; i < numtargets; ++i)
+    {
+        while (*targets[i] == '\0') { targets[i]++; }
+    }
+
+    boolean enchantcheck = false;
+    int enchantexpect = (numtargets > 2) ? 15 : 20;
+
+    //step 4: does the caller care about scrolls of enchantment?
+    for (i = 0; i < numtargets; ++i)
+    {
+        if (strstr(targets[i], "enchan") != NULL)
+        {
+            enchantcheck = true;
+            //search for number
+            int tempenchantexpect = 0;
+            char *firstnumber = targets[i];
+            while (*firstnumber < '0' || *firstnumber > '9') {
+                firstnumber++;
+            }
+            sscanf(firstnumber, "%d", &tempenchantexpect);
+            if (tempenchantexpect > 1 && tempenchantexpect < 99) {
+                enchantexpect = tempenchantexpect;
+            }
+            //scrub entry, decrement numtargets, shuffle target pointers along the array
+            char *p = targets[i];
+            while (*p != '\0') {
+                *p = '\0'; ++p;
+            }
+            for (j = i + 1; j < numtargets; ++j)
+            {
+                targets[j - 1] = targets[j];
+            }
+            --numtargets;
+            if (!gui) {
+                printf("Detected that you care about scrolls of enchanting - %d or more\n", enchantexpect);
+            }
+            break;
+        }
+    }
+
+    boolean mutationcheck = false;
+
+    //step 5: is the caller looking for a mutated ally?
+    for (i = 0; i < numtargets; ++i)
+    {
+        for (j = 0; j < NUMBER_MUTATORS; ++j)
+        {
+            if (strstr(mutationCatalog[j].title, targets[i]) != NULL)
+            {
+                mutationcheck = true;
+                if (!gui) {
+                    printf("Detected that you are looking for a mutated ally - %s\n", targets[i]);
+                }
+                break;
+            }
+        }
+    }
+
+	seedRandomGenerator(0);
+	unsigned long startingSeed = rand_range(0, 1<<25);
+
+	short stopAfterDepth = inahurry ? 2 : (enchantcheck || mutationcheck) ? AMULET_LEVEL : (numtargets > 1) ? 7 : 2;
+    unsigned long seedsTried = 0;
+    unsigned long seedsToTry = (enchantcheck && enchantexpect >= 20) ? 10000 : (numtargets > 1) ? 10000 : (mutationcheck) ? 10000 : 1000;
+    char textbuf[255];
+    char itembuf[255];
+    char monstbuf[255];
+    if (!gui) {
+        printf("Searching for %ld seeds starting with %ld\n", seedsToTry, startingSeed);
+        for (i = 0; i < numtargets; ++i) {
+            printf("'%s'\n", targets[i]);
+        }
+        printf("\n");
+    }
+    fflush(stdout);
+	while (seedsTried < seedsToTry) //plenty
+	{
+
+        if (gui) {
+            //fancy loading bar
+            blackOutScreen();
+            sprintf(textbuf, "Searching, Q to abort");
+            printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 - 1, &teal, &black, 0);
+            sprintf(textbuf, "%ld", seedsTried);
+            printProgressBar((COLS - 20) / 2, ROWS / 2, textbuf,
+                         seedsTried, (seedsToTry*2) - seedsTried, &darkPurple, false);
+            printString(target, (COLS - strLenWithoutEscapes(target)) / 2, ROWS / 2 + 1, &teal, &black, 0);
+            //quit, if we wish
+            if (pauseBrogue(1))
+            {
+                rogueEvent theEvent;
+                nextBrogueEvent(&theEvent, true, false, true);
+                if (theEvent.eventType == KEYSTROKE)
+                {
+                    char key = theEvent.param1;
+                    if (key == ESCAPE_KEY || key == 'Q' || key == 'q')
+                    {return 0;}
+                }
+            }
+        }
+        for (i = 0; i < MAX_TARGETS; ++i) { matches[i] = false;}
+
+		char itemsList[255][255];
+		unsigned char itemsPos = 0;
+		int enchantcount = 0;
+        int strengthcount = 0;
+        int lifecount = 0;
+		initializeRogue(startingSeed, true);
+		rogue.playbackOmniscience = true;
+		//for each floor...
+		while (rogue.depthLevel <= stopAfterDepth)
+		{
+		    if (!gui) { sprintf(itemsList[itemsPos], "Depth %d:", rogue.depthLevel); itemsPos++; }
+            startLevel(max(rogue.depthLevel - 1, 1), 1, true);
+            //for each item, if it's not cursed/negatively enchanted...
+			item *theItem;
+			for (theItem = floorItems; theItem != NULL; theItem = theItem->nextItem) {
+                if (isEnchant(theItem)) ++enchantcount;
+                if (isStrength(theItem)) ++strengthcount;
+                if (isLife(theItem)) ++lifecount;
+			    if (gui) { if (theItem->flags & (ITEM_CURSED) || theItem->enchant1 < 0 || theItem->enchant2 < 0) continue; }
+                theItem->flags = theItem->flags | (ITEM_IDENTIFIED | ITEM_RUNIC_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN);
+                itemName(theItem, itembuf, true, false, NULL);
+                boolean printed = false;
+                //for each of our target items, does a substring match work? when we find one, skip to the next item
+                for (i = 0; i < numtargets; ++i)
+                {
+                    //now each 'token' in the scum entry has to be a substring of the item's full name, not just the entire entry - so you can be abbreviated, get the order wrong, etc
+                    char tokens[255]; strncpy(tokens, targets[i], sizeof(tokens));
+                    boolean nextitemplease = false;
+                    char* pch = strtok(tokens, " ");
+                    for (; pch != NULL; pch = strtok(NULL, " "))
+                    {
+                        //allows for weapon multiplicity, armour multiplicity and so on
+                        if (strcmp("weapon", pch) == 0) { if (theItem->category == WEAPON) { continue; } }
+                        if (strcmp("armour", pch) == 0 || strcmp("armor", pch) == 0) { if (theItem->category == ARMOR) { continue; } }
+                        if (strstr(itembuf, pch) == NULL) { nextitemplease = true; break; }
+                    }
+                    if (nextitemplease) { continue; }
+                    //if (strstr(itembuf, targets[i]) != NULL)
+                    {
+                        if (!gui && !printed)
+                        {
+                            if (pmap[theItem->xLoc][theItem->yLoc].machineNumber > 0)
+                            {
+                                sprintf(textbuf, " (in machine %d)", pmap[theItem->xLoc][theItem->yLoc].machineNumber);
+                                strcat(itembuf, textbuf);
+                            }
+                            sprintf(itemsList[itemsPos], "%s", itembuf);
+                            itemsPos++;
+                            printed = true;
+                        }
+                        if (!matches[i]) { matches[i] = true; break; }
+                    }
+                }
+			}
+			//check for captive allies
+            creature *monst;
+            for (monst = monsters; monst != NULL; monst = monst->nextCreature)
+            {
+                if (monst->bookkeepingFlags & MB_CAPTIVE)
+                {
+                    monsterNameWithMutation(monstbuf, monst, false);
+                    boolean printed = false;
+                    for (i = 0; i < numtargets; ++i)
+                    {
+                        //is target a substring of monster, or is monster a substring of target
+                        //(and immunity is not a substring of target and slaying is not a substring of target)?
+                        if (strstr(monstbuf, targets[i]) != NULL ||
+                            (strstr(targets[i], monstbuf) != NULL && strstr(targets[i], "immun") == NULL && strstr(targets[i], "slay") == NULL))
+                        {
+                            if (!gui && !printed) { sprintf(itemsList[itemsPos], "captive %s", monstbuf); itemsPos++; printed = true;}
+                            if (!matches[i]) { matches[i] = true; break; }
+                        }
+                    }
+                }
+                else if (strcmp(monst->info.monsterName, "black jelly") == 0 ) //for black jelly scumming
+                {
+                    boolean printed = false;
+                    for (i = 0; i < numtargets; ++i)
+                    {
+                        if (strstr("black jelly", targets[i]) != NULL)
+                        {
+                            monsterNameWithMutation(monstbuf, monst, false);
+                            if (!gui && !printed) { sprintf(itemsList[itemsPos], "%s", monstbuf); itemsPos++; printed = true;}
+                            if (!matches[i]) { matches[i] = true; break; }
+                        }
+                    }
+                }
+                //check for items in monsters' pockets too
+                if (monst->carriedItem != NULL)
+                {
+                    theItem = monst->carriedItem;
+                    if (isEnchant(theItem)) ++enchantcount;
+                    if (isStrength(theItem)) ++strengthcount;
+                    if (isLife(theItem)) ++lifecount;
+                    if (gui) { if (theItem->flags & (ITEM_CURSED) || theItem->enchant1 < 0 || theItem->enchant2 < 0) continue; }
+                    theItem->flags = theItem->flags | (ITEM_IDENTIFIED | ITEM_RUNIC_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN);
+                    itemName(theItem, itembuf, true, false, NULL);
+                    boolean printed = false;
+                    //for each of our target items, does a substring match work? when we find one, skip to the next item
+                    for (i = 0; i < numtargets; ++i)
+                    {
+                        //now each 'token' in the scum entry has to be a substring of the item's full name, not just the entire entry - so you can be abbreviated, get the order wrong, etc
+                        char tokens[255]; strncpy(tokens, targets[i], sizeof(tokens));
+                        boolean nextitemplease = false;
+                        char* pch = strtok(tokens, " ");
+                        for (; pch != NULL; pch = strtok(NULL, " "))
+                        {
+                            //allows for weapon multiplicity, armour multiplicity and so on
+                            if (strcmp("weapon", pch) == 0) { if (theItem->category == WEAPON) { continue; } }
+                            if (strcmp("armour", pch) == 0 || strcmp("armor", pch) == 0) { if (theItem->category == ARMOR) { continue; } }
+                            if (strstr(itembuf, pch) == NULL) { nextitemplease = true; break; }
+                        }
+                        if (nextitemplease) { continue; }
+                        //if (strstr(itembuf, targets[i]) != NULL)
+                        {
+                            monsterNameWithMutation(monstbuf, monst, false);
+                            if (!gui && !printed) { sprintf(itemsList[itemsPos], "%s (carried by %s)", itembuf, monstbuf); itemsPos++; printed = true;}
+                            if (!matches[i]) { matches[i] = true; break; }
+                        }
+                    }
+                }
+            }
+
+			rogue.depthLevel++;
+		}
+		rogue.playbackOmniscience = false; emptyGraveyard(); freeEverything();
+		boolean allmatched = true;
+		for (i = 0; i < numtargets; ++i)
+		{
+		    if (!matches[i]) { allmatched = false; break;}
+		}
+
+		if (allmatched && (!enchantcheck || (enchantcheck && (enchantcount >= enchantexpect)))){
+		    if (!gui) {
+                printf("I sense seed %ld has what you seek...\n", startingSeed);
+                for (i = 0; i < itemsPos; i++)
+                {
+                    printf("%s\n", itemsList[i]);
+                }
+                if (enchantcheck) {
+                        printf("\nThat seed had %d enchanting scrolls.\n", enchantcount);
+                        printf("That seed had %d potions of strength.\n", strengthcount);
+                        printf("That seed had %d potions of life.\n", lifecount);
+                }
+                printf("\n");
+                fflush(stdout);
+		    }
+		    else {
+		        blackOutScreen();
+		        sprintf(textbuf, "You shall find '%s' in seed %ld", target, startingSeed);
+		        displayCenteredAlert(textbuf);
+		        sprintf(textbuf, "on the first %d floors...", stopAfterDepth);
+		        printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 1, &teal, &black, 0);
+		        displayMoreSign();
+                return startingSeed;
+		    }
+        }
+
+		startingSeed++; seedsTried++;
+	}
+
+	if (gui) {
+
+	    blackOutScreen();
+	    sprintf(textbuf, "Example searches:");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 3, &teal, &black, 0);
+	    sprintf(textbuf, "quietus");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 4, &teal, &black, 0);
+	    sprintf(textbuf, "+3 axe of quietus");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 5, &teal, &black, 0);
+	    sprintf(textbuf, "quietus, plate");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 6, &teal, &black, 0);
+	    sprintf(textbuf, "staff of obstruction [4/4]");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 7, &teal, &black, 0);
+	    sprintf(textbuf, "wand of plenty [4]");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 8, &teal, &black, 0);
+	    sprintf(textbuf, "stealth, war hammer, +3 ring of awareness");
+	    printString(textbuf, (COLS - strLenWithoutEscapes(textbuf)) / 2, ROWS / 2 + 9, &teal, &black, 0);
+	    sprintf(textbuf, "Didn't find '%s' in %ld seeds. Try again?", target, seedsToTry);
+        if (confirm(textbuf, true)) return startScum(target, gui, inahurry);
+	 }
+	 else {
+        printf("Searched %ld seeds. I'm done.\n", seedsTried);
+	 }
+	return 0;
+}
+
+//end seed scumming functions
 
 void freeGlobalDynamicGrid(short ***grid) {
 	if (*grid) {
diff -Bwur "Brogue Source (Original)/BrogueCode/Time.c" "Brogue Source/BrogueCode/Time.c"
--- "Brogue Source (Original)/BrogueCode/Time.c"	2014-07-30 08:32:39.100000100 +1000
+++ "Brogue Source/BrogueCode/Time.c"	2014-07-30 11:01:54.541732700 +1000
@@ -954,7 +954,7 @@
     
     if (rogue.depthLevel < DEEPEST_LEVEL) {
         rogue.depthLevel++;
-        startLevel(rogue.depthLevel - 1, 0);
+        startLevel(rogue.depthLevel - 1, 0, false);
         damage = randClumpedRange(FALL_DAMAGE_MIN, FALL_DAMAGE_MAX, 2);
         messageWithColor("You are damaged by the fall.", &badMessageColor, false);
         if (inflictDamage(NULL, &player, damage, &red, false)) {
diff -Bwur "Brogue Source (Original)/PlatformCode/main.c" "Brogue Source/PlatformCode/main.c"
--- "Brogue Source (Original)/PlatformCode/main.c"	2014-07-30 08:32:40.253090700 +1000
+++ "Brogue Source/PlatformCode/main.c"	2014-07-30 11:01:54.554733100 +1000
@@ -89,6 +89,36 @@
 			return 0;
 		}
 
+		if (strcmp(argv[i], "--scum") == 0 && (i+1) < argc) {
+			// scum and quit
+			if ((i+2) >= argc)
+			{
+			    printf("Scumming for: %s\n", argv[i+1]);
+                startScum(argv[i+1], false, false);
+                return 0;
+			}
+			char target[255]; memset(target, '\0', sizeof(char)*255);
+			int k = i + 1;
+			for (; k < argc; ++k)
+			{
+			    strcat(target, argv[k]);
+			    if ((k+1) < argc)
+			    {
+			        strcat(target, " ");
+			    }
+			}
+			printf("Scumming for: %s\n", target);
+			startScum(target, false);
+			return 0;
+		}
+
+		if (strcmp(argv[i], "--viewseed") == 0 && (i+1) < argc) {
+            //seed peer and quit
+            printf("Peering at contents of seed: %s\n", argv[i+1]);
+            seedPeer(atol(argv[i+1]));
+            return 0;
+		}
+
 		if (strcmp(argv[i], "--seed") == 0 || strcmp(argv[i], "-s") == 0) {
 			// pick a seed!
 			if (i + 1 < argc) {
diff -Bwur "Brogue Source (Original)/PlatformCode/tcod-platform.c" "Brogue Source/PlatformCode/tcod-platform.c"
--- "Brogue Source (Original)/PlatformCode/tcod-platform.c"	2014-07-30 08:32:42.644276300 +1000
+++ "Brogue Source/PlatformCode/tcod-platform.c"	2014-07-30 11:01:54.563734100 +1000
@@ -7,7 +7,7 @@
 #include "platform.h"
 
 #if TCOD_TECHVERSION >= 0x01050103
-#define USE_NEW_TCOD_API
+//#define USE_NEW_TCOD_API
 #endif
 
 extern playerCharacter rogue;
